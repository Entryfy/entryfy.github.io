{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To get started with developing against the Entryfy platform you will need an account and some hardware to verify that your code works as intended. Please reach out to sales@entryfy.com to get help setting up an Entryfy account and we will help you getting some hardware from a local distributer. Getting Started Please read through this section to get an introduction of how the Entryfy Platform works and some of the concepts behind it. Building Here you can follow along with some examples of how to get started integrating your business with Entryfy.","title":"Welcome"},{"location":"#welcome","text":"To get started with developing against the Entryfy platform you will need an account and some hardware to verify that your code works as intended. Please reach out to sales@entryfy.com to get help setting up an Entryfy account and we will help you getting some hardware from a local distributer.","title":"Welcome"},{"location":"#getting-started","text":"Please read through this section to get an introduction of how the Entryfy Platform works and some of the concepts behind it.","title":"Getting Started"},{"location":"#building","text":"Here you can follow along with some examples of how to get started integrating your business with Entryfy.","title":"Building"},{"location":"building/auth/","text":"Authentication Create session First step is creating a message, CreateSessionRequest, with username, password and a device UUID. The device_uuid is an identifier from which resource the request has been made. The device_uuid needs to be unique per user and resource. If the client authenticates with the same device_uuid from another resource all other sessions will be terminated. message CreateSessionRequest { string username = 1 ; string password = 2 ; string device_uuid = 3 ; } The message is sent to the SessionService to get back an authentication token that the client will use in subsequent requests and an reissue token that will be used to re-authentication as explained below. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: CreateSessionRequest SessionsService-->>Client: CreateSessionResponse Store the tokens in some form of local cache so it is available to the client and don't re-authenticate on each request. message CreateSessionResponse { string auth_token = 1 ; string reissue_token = 2 ; uint32 exp = 3 ; uint64 user_id = 4 ; string username = 5 ; string user_uuid = 6 ; } Re-issue session An authentication token (auth_token) is valid for 2 weeks and to extend the validity the client can send an request to reissue the token which extends it an additional two weeks. message ReissueSessionRequest { string reissue_token = 1 ; } To re-issue an authentication token you need to send an ReissueSessionRequest with the reissue token returned when the session was created. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: ReissueSessionRequest SessionsService-->>Client: ReissueSessionResponse You will get back an ReissueSessionResponse with the extend auth_token and a new re-issue token if you need to extend the validity further. message ReissueSessionResponse { string auth_token = 1 ; string reissue_token = 2 ; uint32 exp = 3 ; uint64 user_id = 4 ; string username = 5 ; string user_uuid = 6 ; } Destroy session To invalidate an authentication session send an empty DestroySessionRequest message to the SessionsService. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: DestroySessionRequest SessionsService-->>Client: DestroySessionResponse message DestroySessionRequest { } You will get back an empty DestroySessionResponse to confirm that the auth token has been invalidated. message DestroySessionResponse { }","title":"Authentication"},{"location":"building/auth/#authentication","text":"","title":"Authentication"},{"location":"building/auth/#create-session","text":"First step is creating a message, CreateSessionRequest, with username, password and a device UUID. The device_uuid is an identifier from which resource the request has been made. The device_uuid needs to be unique per user and resource. If the client authenticates with the same device_uuid from another resource all other sessions will be terminated. message CreateSessionRequest { string username = 1 ; string password = 2 ; string device_uuid = 3 ; } The message is sent to the SessionService to get back an authentication token that the client will use in subsequent requests and an reissue token that will be used to re-authentication as explained below. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: CreateSessionRequest SessionsService-->>Client: CreateSessionResponse Store the tokens in some form of local cache so it is available to the client and don't re-authenticate on each request. message CreateSessionResponse { string auth_token = 1 ; string reissue_token = 2 ; uint32 exp = 3 ; uint64 user_id = 4 ; string username = 5 ; string user_uuid = 6 ; }","title":"Create session"},{"location":"building/auth/#re-issue-session","text":"An authentication token (auth_token) is valid for 2 weeks and to extend the validity the client can send an request to reissue the token which extends it an additional two weeks. message ReissueSessionRequest { string reissue_token = 1 ; } To re-issue an authentication token you need to send an ReissueSessionRequest with the reissue token returned when the session was created. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: ReissueSessionRequest SessionsService-->>Client: ReissueSessionResponse You will get back an ReissueSessionResponse with the extend auth_token and a new re-issue token if you need to extend the validity further. message ReissueSessionResponse { string auth_token = 1 ; string reissue_token = 2 ; uint32 exp = 3 ; uint64 user_id = 4 ; string username = 5 ; string user_uuid = 6 ; }","title":"Re-issue session"},{"location":"building/auth/#destroy-session","text":"To invalidate an authentication session send an empty DestroySessionRequest message to the SessionsService. sequenceDiagram participant Client participant SessionsService Client->>SessionsService: DestroySessionRequest SessionsService-->>Client: DestroySessionResponse message DestroySessionRequest { } You will get back an empty DestroySessionResponse to confirm that the auth token has been invalidated. message DestroySessionResponse { }","title":"Destroy session"},{"location":"getting-started/concepts/","text":"Concepts Asynchronous Entryfy Platform is built on the principle of asynchronous communication since connectivity to IoT devices can be prone to delay or interruption. There won't be an immediate response with a resources identifier and instead developers are encouraged to use UUID, universally unique identifier, to identity and query for resources in Entryfy Platform. Business Operations (BizOperation) A business operation is the heart of the process life cycle at Entryfy. It is returned whenever you create, update or delete something within the platform. It is used to track the process of the request and go through the different statuses listed below. Accepted Pending Failed or Finished You can either query our BizOperation endpoint or you can listen to a stream that will return BizOperations as they are transformed. This way you can be sure that you deliver credentials to customers when the data is available locally and no one is stuck waiting outside for someone else to open the door.","title":"Concepts"},{"location":"getting-started/concepts/#concepts","text":"","title":"Concepts"},{"location":"getting-started/concepts/#asynchronous","text":"Entryfy Platform is built on the principle of asynchronous communication since connectivity to IoT devices can be prone to delay or interruption. There won't be an immediate response with a resources identifier and instead developers are encouraged to use UUID, universally unique identifier, to identity and query for resources in Entryfy Platform.","title":"Asynchronous"},{"location":"getting-started/concepts/#business-operations-bizoperation","text":"A business operation is the heart of the process life cycle at Entryfy. It is returned whenever you create, update or delete something within the platform. It is used to track the process of the request and go through the different statuses listed below. Accepted Pending Failed or Finished You can either query our BizOperation endpoint or you can listen to a stream that will return BizOperations as they are transformed. This way you can be sure that you deliver credentials to customers when the data is available locally and no one is stuck waiting outside for someone else to open the door.","title":"Business Operations (BizOperation)"},{"location":"getting-started/introduction/","text":"An introduction to the Entryfy platform Entryfy lets you integrate and automate physical access control into your exisiting business workflows. We have chosen to use gRPC and protocol buffers for our internal and external API to streamline the development process and simplify for external developers. gRPC gRPC allows you to generate clientside boilerplate code to interact with the Entryfy Platform directly through a method call as if it were a local object thus speeding up the development cycle. Don't worry, we have lots of examples of how to get started with gRPC, it was new to us too when we started out! You should also take a look at the offical documentation for a deeper explanation of the concepts behind the technology. https://grpc.io/docs/ Protocol Buffers Protocol buffers are Google's language-neutral mechanism for serializing structured data. You define your data once, then you can use gRPC, as described above, to generated source code to easily communicate with the Entrfyfy Platform using a variety of languages. https://github.com/entryfy/protobuffers","title":"Introduction"},{"location":"getting-started/introduction/#an-introduction-to-the-entryfy-platform","text":"Entryfy lets you integrate and automate physical access control into your exisiting business workflows. We have chosen to use gRPC and protocol buffers for our internal and external API to streamline the development process and simplify for external developers.","title":"An introduction to the Entryfy platform"},{"location":"getting-started/introduction/#grpc","text":"gRPC allows you to generate clientside boilerplate code to interact with the Entryfy Platform directly through a method call as if it were a local object thus speeding up the development cycle. Don't worry, we have lots of examples of how to get started with gRPC, it was new to us too when we started out! You should also take a look at the offical documentation for a deeper explanation of the concepts behind the technology. https://grpc.io/docs/","title":"gRPC"},{"location":"getting-started/introduction/#protocol-buffers","text":"Protocol buffers are Google's language-neutral mechanism for serializing structured data. You define your data once, then you can use gRPC, as described above, to generated source code to easily communicate with the Entrfyfy Platform using a variety of languages. https://github.com/entryfy/protobuffers","title":"Protocol Buffers"}]}